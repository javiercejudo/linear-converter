{"version":3,"sources":["linear-converter.js"],"names":["require","e","t","n","r","s","o","u","a","i","f","Error","code","l","exports","call","length",1,"module","optionale","optioanlDependency","er",2,"decimal","load","isAvailable",3,"normaliseDecimal","x","scale","minus","div","normaliseNative","arbitraryPrecision","normalise","Number","rescale-arbitrary-precision",4,"scaleDecimal","times","plus","scaleNative",5,"rescaleDecimal","oldScale","newScale","rescaleNative","rescale","scale-normalised","linear-converter","compose2presets","presetA","presetB","map","getCoefficientANative","preset","getCoefficientADecimal","convert","invertPreset","slice","reverse","composePresets","presets","reduce","getCoefficientA","getCoefficientB"],"mappings":"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","file":"linear-converter.min.js","sourcesContent":["/**\n * linear-converter - Copyright 2015 Javier Cejudo <javier@javiercejudo.com> (http://www.javiercejudo.com)\n * @version v2.0.0\n * @link https://github.com/javiercejudo/linear-converter#readme\n * @license MIT\n */\nrequire=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/*jshint node:true */\n\n'use strict';\n\n/**\n * Returns the package for the given name if found or undefined otherwise\n *\n * @param  {String} The name of the package to load\n *\n * @return {*}\n */\nexports.optionale = function optionale(optioanlDependency) {\n  try {\n    return require(optioanlDependency);\n  } catch (er) {\n    return;\n  }\n};\n\n},{}],2:[function(require,module,exports){\n/*jshint node:true */\n\n'use strict';\n\nvar optionale = require('optionale');\n\nvar decimal;\n\n/**\n * Returns arbitrary precision library if available or undefined otherwise\n *\n * @return {*}\n */\nexports.load = function load() {\n  decimal = optionale.optionale('big.js');\n\n  return decimal;\n};\n\n/**\n * Returns true if arbitrary precision is available and false otherwise\n *\n * @return {Boolean} Arbitrary precision availability\n */\nexports.isAvailable = function isAvailable() {\n  return typeof decimal !== 'undefined';\n};\n\n},{\"optionale\":1}],3:[function(require,module,exports){\n/*jshint node:true */\n\n'use strict';\n\nvar arbitraryPrecision = require('rescale-arbitrary-precision');\n\nvar decimal = arbitraryPrecision.load();\n\nexports.normalise = function normalise(x, scale) {\n  if (typeof scale === 'undefined') {\n    return x;\n  }\n\n  if (arbitraryPrecision.isAvailable()) {\n    return Number(normaliseDecimal(x, scale));\n  }\n\n  return normaliseNative(x, scale);\n};\n\nfunction normaliseDecimal(x, scale) {\n  return decimal(x).minus(scale[0])\n    .div(decimal(scale[1]).minus(scale[0]));\n}\n\nfunction normaliseNative(x, scale) {\n  return (x - scale[0]) / (scale[1] - scale[0]);\n}\n\n},{\"rescale-arbitrary-precision\":2}],4:[function(require,module,exports){\n/*jshint node:true */\n\n'use strict';\n\nvar arbitraryPrecision = require('rescale-arbitrary-precision');\n\nvar decimal = arbitraryPrecision.load();\n\nexports.scale = function scaleNormalised(x, scale) {\n  if (typeof scale === 'undefined') {\n    return x;\n  }\n\n  if (arbitraryPrecision.isAvailable()) {\n    return Number(scaleDecimal(x, scale));\n  }\n\n  return scaleNative(x, scale);\n};\n\nfunction scaleDecimal(x, scale) {\n  return decimal(scale[1]).minus(scale[0]).times(x).plus(scale[0]);\n}\n\nfunction scaleNative(x, scale) {\n  return scale[0] + x * (scale[1] - scale[0]);\n}\n\n},{\"rescale-arbitrary-precision\":2}],5:[function(require,module,exports){\n/*jshint node:true */\n\n'use strict';\n\nvar normalise = require('normalise');\nvar scale = require('scale-normalised');\nvar arbitraryPrecision = require('rescale-arbitrary-precision');\n\nvar decimal = arbitraryPrecision.load();\n\nexports.rescale = function rescale(x, oldScale, newScale) {\n  if (typeof newScale === 'undefined') {\n    return normalise.normalise(x, oldScale);\n  }\n\n  if (arbitraryPrecision.isAvailable()) {\n    return Number(rescaleDecimal(x, oldScale, newScale));\n  }\n\n  return rescaleNative(x, oldScale, newScale);\n};\n\nfunction rescaleDecimal(x, oldScale, newScale) {\n  return scaleDecimal(normaliseDecimal(x, oldScale), newScale);\n}\n\nfunction normaliseDecimal(x, scale) {\n  return decimal(x).minus(scale[0])\n    .div(decimal(scale[1]).minus(scale[0]));\n}\n\nfunction scaleDecimal(x, scale) {\n  return decimal(scale[1]).minus(scale[0]).times(x).plus(scale[0]);\n}\n\nfunction rescaleNative(x, oldScale, newScale) {\n  return scale.scale(normalise.normalise(x, oldScale), newScale);\n}\n\n},{\"normalise\":3,\"rescale-arbitrary-precision\":2,\"scale-normalised\":4}],\"linear-converter\":[function(require,module,exports){\n/*jshint node:true */\n\n'use strict';\n\nvar rescale = require('rescale');\nvar arbitraryPrecision = require('rescale-arbitrary-precision');\n\nvar decimal = arbitraryPrecision.load();\n\n/**\n * Linearly converts x as described by a preset\n *\n * @param  {Number} x The number to be converted\n * @param  {Array} preset The preset that describes the conversion\n *\n * @return {Number} The converted x\n */\nexports.convert = function convert(x, preset) {\n  return rescale.rescale(x, preset[0], preset[1]);\n};\n\n/**\n * Inverts a preset to change the direction of the conversion\n *\n * @param {Array} preset The preset to invert\n *\n * @return {Array} The inverted preset\n */\nexports.invertPreset = function invertPreset(preset) {\n  return preset.slice(0).reverse();\n};\n\n/**\n * Composes two or more presets to create a single preset\n *\n * @param {Array} presets The array of the presets to compose\n *\n * @return {Array} The composed preset\n */\nexports.composePresets = function composePresets(presets) {\n  return presets.reduce(compose2presets);\n};\n\n/**\n * Calculates the a coefficient in the f(x) = ax + b function that describes\n * the given preset.\n *\n * @param {Array} preset The preset for which to calculate its a coefficient\n *\n * @return {Number} The coefficient a\n */\nexports.getCoefficientA = function getCoefficientA(preset) {\n  if (arbitraryPrecision.isAvailable()) {\n    return Number(getCoefficientADecimal(preset));\n  }\n\n  return getCoefficientANative(preset);\n};\n\n/**\n * Calculates the b coefficient in the f(x) = ax + b function that describes\n * the given preset.\n *\n * @param {Array} preset The preset for which to calculate its b coefficient\n *\n * @return {Number} The coefficient b\n */\nexports.getCoefficientB = function getCoefficientB(preset) {\n  return rescale.rescale(0, preset[0], preset[1]);\n};\n\n/**\n * Composes two presets to create a single preset\n *\n * @param {Array} presetA The first preset to compose\n * @param {Array} presetB The second preset to compose\n *\n * @return {Array} The composed preset\n */\nfunction compose2presets(presetA, presetB) {\n  return [\n    presetA[0],\n    presetA[1].map(function(x) {\n      return rescale.rescale(x, presetB[0], presetB[1]);\n    })\n  ];\n}\n\n/**\n * Calculates the a coefficient in the f(x) = ax + b function that describes\n * the given preset using floating-point numbers.\n *\n * @param {Array} preset The preset for which to calculate its a coefficient\n *\n * @return {Number} The coefficient a\n */\nfunction getCoefficientANative(preset) {\n  return (preset[1][1] - preset[1][0]) / (preset[0][1] - preset[0][0]);\n}\n\n/**\n * Calculates the a coefficient in the f(x) = ax + b function that describes\n * the given preset using arbitrary precision.\n *\n * @param {Array} preset The preset for which to calculate its a coefficient\n *\n * @return {Big} The coefficient a\n */\nfunction getCoefficientADecimal(preset) {\n  return decimal(preset[1][1]).minus(preset[1][0])\n    .div(decimal(preset[0][1]).minus(preset[0][0]));\n}\n\n},{\"rescale\":5,\"rescale-arbitrary-precision\":2}]},{},[]);\n"],"sourceRoot":"/source/"}